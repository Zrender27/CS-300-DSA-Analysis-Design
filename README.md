# CS-300-DSA-Analysis-Design
In this course, I worked on solving problems related to organizing and managing large sets of data efficiently using different data structures. Specifically, my project focused on building a Bid Processing System that could load, search, insert, and remove bids from a dataset. The challenge was not only to make the program functional but also to ensure that operations were optimized for performance depending on which data structure—such as a linked list, hash table, or binary search tree—was used.
My approach began with analyzing the core problem: how to store and retrieve data in the most efficient way possible. Understanding data structures was essential because each one provides unique trade-offs between time and space complexity. For example, linked lists make insertions simple but are slow for searches, while binary search trees allow fast searches if balanced. By comparing these structures, I was able to determine which implementation best met the project’s requirements.
Throughout the project, I encountered several roadblocks—such as handling pointer errors, debugging tree traversal logic, and ensuring data was loaded correctly from CSV files. I overcame these challenges by incrementally testing functions, reviewing algorithm flow step-by-step, and using debugging output to trace data through my code. Consulting course materials and applying logical reasoning helped me identify where my assumptions about data flow were incorrect and fix them systematically.
Completing this project has expanded my approach to software design and program development. I now design with scalability and clarity in mind—structuring programs into smaller, reusable components and selecting data structures deliberately based on the problem’s needs rather than by habit. It reinforced that good software design is about balancing performance, clarity, and adaptability.
This project also evolved the way I write code that is maintainable, readable, and adaptable. I improved my use of consistent naming conventions, inline documentation, and modular design. I now think ahead about how another developer—or my future self—might modify or extend the program. I’ve learned to prioritize clean structure, clear logic, and efficiency equally, which will continue to guide how I approach software engineering challenges going forward.
